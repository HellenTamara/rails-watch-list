import*as e from"domutils";import t from"boolbase";import{SelectorType as n,AttributeAction as r,parse as s}from"css-what";import o from"nth-check";const a=new Map([[n.Universal,50],[n.Tag,30],[n.Attribute,1],[n.Pseudo,0]]);function isTraversal(e){return!a.has(e.type)}const i=new Map([[r.Exists,10],[r.Equals,8],[r.Not,7],[r.Start,6],[r.End,6],[r.Any,5]]);
/**
 * Sort the parts of the passed selector,
 * as there is potential for optimization
 * (some types of selectors are faster than others)
 *
 * @param arr Selector to sort
 */function sortByProcedure(e){const t=e.map(getProcedure);for(let n=1;n<e.length;n++){const r=t[n];if(!(r<0))for(let s=n-1;s>=0&&r<t[s];s--){const n=e[s+1];e[s+1]=e[s];e[s]=n;t[s+1]=t[s];t[s]=r}}}function getProcedure(e){var t,s;let o=null!==(t=a.get(e.type))&&void 0!==t?t:-1;if(e.type===n.Attribute){o=null!==(s=i.get(e.action))&&void 0!==s?s:4;e.action===r.Equals&&"id"===e.name&&(o=9);e.ignoreCase&&(o>>=1)}else if(e.type===n.Pseudo)if(e.data)if("has"===e.name||"contains"===e.name)o=0;else if(Array.isArray(e.data)){o=Math.min(...e.data.map((e=>Math.min(...e.map(getProcedure)))));o<0&&(o=0)}else o=2;else o=3;return o}const u=/[-[\]{}()*+?.,\\^$|#\s]/g;function escapeRegex(e){return e.replace(u,"\\$&")}const l=new Set(["accept","accept-charset","align","alink","axis","bgcolor","charset","checked","clear","codetype","color","compact","declare","defer","dir","direction","disabled","enctype","face","frame","hreflang","http-equiv","lang","language","link","media","method","multiple","nohref","noresize","noshade","nowrap","readonly","rel","rev","rules","scope","scrolling","selected","shape","target","text","type","valign","valuetype","vlink"]);function shouldIgnoreCase(e,t){return"boolean"===typeof e.ignoreCase?e.ignoreCase:"quirks"===e.ignoreCase?!!t.quirksMode:!t.xmlMode&&l.has(e.name)}const c={equals(e,t,n){const{adapter:r}=n;const{name:s}=t;let{value:o}=t;if(shouldIgnoreCase(t,n)){o=o.toLowerCase();return t=>{const n=r.getAttributeValue(t,s);return null!=n&&n.length===o.length&&n.toLowerCase()===o&&e(t)}}return t=>r.getAttributeValue(t,s)===o&&e(t)},hyphen(e,t,n){const{adapter:r}=n;const{name:s}=t;let{value:o}=t;const a=o.length;if(shouldIgnoreCase(t,n)){o=o.toLowerCase();return function hyphenIC(t){const n=r.getAttributeValue(t,s);return null!=n&&(n.length===a||"-"===n.charAt(a))&&n.substr(0,a).toLowerCase()===o&&e(t)}}return function hyphen(t){const n=r.getAttributeValue(t,s);return null!=n&&(n.length===a||"-"===n.charAt(a))&&n.substr(0,a)===o&&e(t)}},element(e,n,r){const{adapter:s}=r;const{name:o,value:a}=n;if(/\s/.test(a))return t.falseFunc;const i=new RegExp(`(?:^|\\s)${escapeRegex(a)}(?:$|\\s)`,shouldIgnoreCase(n,r)?"i":"");return function element(t){const n=s.getAttributeValue(t,o);return null!=n&&n.length>=a.length&&i.test(n)&&e(t)}},exists(e,{name:t},{adapter:n}){return r=>n.hasAttrib(r,t)&&e(r)},start(e,n,r){const{adapter:s}=r;const{name:o}=n;let{value:a}=n;const i=a.length;if(0===i)return t.falseFunc;if(shouldIgnoreCase(n,r)){a=a.toLowerCase();return t=>{const n=s.getAttributeValue(t,o);return null!=n&&n.length>=i&&n.substr(0,i).toLowerCase()===a&&e(t)}}return t=>{var n;return!!(null===(n=s.getAttributeValue(t,o))||void 0===n?void 0:n.startsWith(a))&&e(t)}},end(e,n,r){const{adapter:s}=r;const{name:o}=n;let{value:a}=n;const i=-a.length;if(0===i)return t.falseFunc;if(shouldIgnoreCase(n,r)){a=a.toLowerCase();return t=>{var n;return(null===(n=s.getAttributeValue(t,o))||void 0===n?void 0:n.substr(i).toLowerCase())===a&&e(t)}}return t=>{var n;return!!(null===(n=s.getAttributeValue(t,o))||void 0===n?void 0:n.endsWith(a))&&e(t)}},any(e,n,r){const{adapter:s}=r;const{name:o,value:a}=n;if(""===a)return t.falseFunc;if(shouldIgnoreCase(n,r)){const t=new RegExp(escapeRegex(a),"i");return function anyIC(n){const r=s.getAttributeValue(n,o);return null!=r&&r.length>=a.length&&t.test(r)&&e(n)}}return t=>{var n;return!!(null===(n=s.getAttributeValue(t,o))||void 0===n?void 0:n.includes(a))&&e(t)}},not(e,t,n){const{adapter:r}=n;const{name:s}=t;let{value:o}=t;if(""===o)return t=>!!r.getAttributeValue(t,s)&&e(t);if(shouldIgnoreCase(t,n)){o=o.toLowerCase();return t=>{const n=r.getAttributeValue(t,s);return(null==n||n.length!==o.length||n.toLowerCase()!==o)&&e(t)}}return t=>r.getAttributeValue(t,s)!==o&&e(t)}};function getChildFunc(e,t){return n=>{const r=t.getParent(n);return null!=r&&t.isTag(r)&&e(n)}}const d={contains(e,t,{adapter:n}){return function contains(r){return e(r)&&n.getText(r).includes(t)}},icontains(e,t,{adapter:n}){const r=t.toLowerCase();return function icontains(t){return e(t)&&n.getText(t).toLowerCase().includes(r)}},"nth-child"(e,n,{adapter:r,equals:s}){const a=o(n);return a===t.falseFunc?t.falseFunc:a===t.trueFunc?getChildFunc(e,r):function nthChild(t){const n=r.getSiblings(t);let o=0;for(let e=0;e<n.length;e++){if(s(t,n[e]))break;r.isTag(n[e])&&o++}return a(o)&&e(t)}},"nth-last-child"(e,n,{adapter:r,equals:s}){const a=o(n);return a===t.falseFunc?t.falseFunc:a===t.trueFunc?getChildFunc(e,r):function nthLastChild(t){const n=r.getSiblings(t);let o=0;for(let e=n.length-1;e>=0;e--){if(s(t,n[e]))break;r.isTag(n[e])&&o++}return a(o)&&e(t)}},"nth-of-type"(e,n,{adapter:r,equals:s}){const a=o(n);return a===t.falseFunc?t.falseFunc:a===t.trueFunc?getChildFunc(e,r):function nthOfType(t){const n=r.getSiblings(t);let o=0;for(let e=0;e<n.length;e++){const a=n[e];if(s(t,a))break;r.isTag(a)&&r.getName(a)===r.getName(t)&&o++}return a(o)&&e(t)}},"nth-last-of-type"(e,n,{adapter:r,equals:s}){const a=o(n);return a===t.falseFunc?t.falseFunc:a===t.trueFunc?getChildFunc(e,r):function nthLastOfType(t){const n=r.getSiblings(t);let o=0;for(let e=n.length-1;e>=0;e--){const a=n[e];if(s(t,a))break;r.isTag(a)&&r.getName(a)===r.getName(t)&&o++}return a(o)&&e(t)}},root(e,t,{adapter:n}){return t=>{const r=n.getParent(t);return(null==r||!n.isTag(r))&&e(t)}},scope(e,t,n,r){const{equals:s}=n;return r&&0!==r.length?1===r.length?t=>s(r[0],t)&&e(t):t=>r.includes(t)&&e(t):d.root(e,t,n)},hover:dynamicStatePseudo("isHovered"),visited:dynamicStatePseudo("isVisited"),active:dynamicStatePseudo("isActive")};
/**
 * Dynamic state pseudos. These depend on optional Adapter methods.
 *
 * @param name The name of the adapter method to call.
 * @returns Pseudo for the `filters` object.
 */function dynamicStatePseudo(e){return function dynamicPseudo(n,r,{adapter:s}){const o=s[e];return"function"!==typeof o?t.falseFunc:function active(e){return o(e)&&n(e)}}}const f={empty(e,{adapter:t}){return!t.getChildren(e).some((e=>t.isTag(e)||""!==t.getText(e)))},"first-child"(e,{adapter:t,equals:n}){if(t.prevElementSibling)return null==t.prevElementSibling(e);const r=t.getSiblings(e).find((e=>t.isTag(e)));return null!=r&&n(e,r)},"last-child"(e,{adapter:t,equals:n}){const r=t.getSiblings(e);for(let s=r.length-1;s>=0;s--){if(n(e,r[s]))return true;if(t.isTag(r[s]))break}return false},"first-of-type"(e,{adapter:t,equals:n}){const r=t.getSiblings(e);const s=t.getName(e);for(let o=0;o<r.length;o++){const a=r[o];if(n(e,a))return true;if(t.isTag(a)&&t.getName(a)===s)break}return false},"last-of-type"(e,{adapter:t,equals:n}){const r=t.getSiblings(e);const s=t.getName(e);for(let o=r.length-1;o>=0;o--){const a=r[o];if(n(e,a))return true;if(t.isTag(a)&&t.getName(a)===s)break}return false},"only-of-type"(e,{adapter:t,equals:n}){const r=t.getName(e);return t.getSiblings(e).every((s=>n(e,s)||!t.isTag(s)||t.getName(s)!==r))},"only-child"(e,{adapter:t,equals:n}){return t.getSiblings(e).every((r=>n(e,r)||!t.isTag(r)))}};function verifyPseudoArgs(e,t,n,r){if(null===n){if(e.length>r)throw new Error(`Pseudo-class :${t} requires an argument`)}else if(e.length===r)throw new Error(`Pseudo-class :${t} doesn't have any arguments`)}const p={"any-link":":is(a, area, link)[href]",link:":any-link:not(:visited)",disabled:":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",enabled:":not(:disabled)",checked:":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",required:":is(input, select, textarea)[required]",optional:":is(input, select, textarea):not([required])",selected:"option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",checkbox:"[type=checkbox]",file:"[type=file]",password:"[type=password]",radio:"[type=radio]",reset:"[type=reset]",image:"[type=image]",submit:"[type=submit]",parent:":not(:empty)",header:":is(h1, h2, h3, h4, h5, h6)",button:":is(button, input[type=button])",input:":is(input, textarea, select, button)",text:"input:is(:not([type!='']), [type=text])"};const g={};function ensureIsTag(e,n){return e===t.falseFunc?t.falseFunc:t=>n.isTag(t)&&e(t)}function getNextSiblings(e,t){const n=t.getSiblings(e);if(n.length<=1)return[];const r=n.indexOf(e);return r<0||r===n.length-1?[]:n.slice(r+1).filter(t.isTag)}function copyOptions(e){return{xmlMode:!!e.xmlMode,lowerCaseAttributeNames:!!e.lowerCaseAttributeNames,lowerCaseTags:!!e.lowerCaseTags,quirksMode:!!e.quirksMode,cacheResults:!!e.cacheResults,pseudos:e.pseudos,adapter:e.adapter,equals:e.equals}}const is$1=(e,n,r,s,o)=>{const a=o(n,copyOptions(r),s);return a===t.trueFunc?e:a===t.falseFunc?t.falseFunc:t=>a(t)&&e(t)};const h={is:is$1,matches:is$1,where:is$1,not(e,n,r,s,o){const a=o(n,copyOptions(r),s);return a===t.falseFunc?e:a===t.trueFunc?t.falseFunc:t=>!a(t)&&e(t)},has(e,n,r,s,o){const{adapter:a}=r;const i=copyOptions(r);i.relativeSelector=true;const u=n.some((e=>e.some(isTraversal)))?[g]:void 0;const l=o(n,i,u);if(l===t.falseFunc)return t.falseFunc;const c=ensureIsTag(l,a);if(u&&l!==t.trueFunc){const{shouldTestNextSiblings:t=false}=l;return n=>{if(!e(n))return false;u[0]=n;const r=a.getChildren(n);const s=t?[...r,...getNextSiblings(n,a)]:r;return a.existsOne(c,s)}}return t=>e(t)&&a.existsOne(c,a.getChildren(t))}};function compilePseudoSelector(e,t,n,r,o){var a;const{name:i,data:u}=t;if(Array.isArray(u)){if(!(i in h))throw new Error(`Unknown pseudo-class :${i}(${u})`);return h[i](e,u,n,r,o)}const l=null===(a=n.pseudos)||void 0===a?void 0:a[i];const c="string"===typeof l?l:p[i];if("string"===typeof c){if(null!=u)throw new Error(`Pseudo ${i} doesn't have any arguments`);const t=s(c);return h.is(e,t,n,r,o)}if("function"===typeof l){verifyPseudoArgs(l,i,u,1);return t=>l(t,u)&&e(t)}if(i in d)return d[i](e,u,n,r);if(i in f){const t=f[i];verifyPseudoArgs(t,i,u,2);return r=>t(r,n,u)&&e(r)}throw new Error(`Unknown pseudo-class :${i}`)}function getElementParent(e,t){const n=t.getParent(e);return n&&t.isTag(n)?n:null}function compileGeneralSelector(e,t,r,s,o){const{adapter:a,equals:i}=r;switch(t.type){case n.PseudoElement:throw new Error("Pseudo-elements are not supported by css-select");case n.ColumnCombinator:throw new Error("Column combinators are not yet supported by css-select");case n.Attribute:if(null!=t.namespace)throw new Error("Namespaced attributes are not yet supported by css-select");r.xmlMode&&!r.lowerCaseAttributeNames||(t.name=t.name.toLowerCase());return c[t.action](e,t,r);case n.Pseudo:return compilePseudoSelector(e,t,r,s,o);case n.Tag:{if(null!=t.namespace)throw new Error("Namespaced tag names are not yet supported by css-select");let{name:n}=t;r.xmlMode&&!r.lowerCaseTags||(n=n.toLowerCase());return function tag(t){return a.getName(t)===n&&e(t)}}case n.Descendant:{if(false===r.cacheResults||"undefined"===typeof WeakSet)return function descendant(t){let n=t;while(n=getElementParent(n,a))if(e(n))return true;return false};const t=new WeakSet;return function cachedDescendant(n){let r=n;while(r=getElementParent(r,a))if(!t.has(r)){if(a.isTag(r)&&e(r))return true;t.add(r)}return false}}case"_flexibleDescendant":return function flexibleDescendant(t){let n=t;do{if(e(n))return true}while(n=getElementParent(n,a));return false};case n.Parent:return function parent(t){return a.getChildren(t).some((t=>a.isTag(t)&&e(t)))};case n.Child:return function child(t){const n=a.getParent(t);return null!=n&&a.isTag(n)&&e(n)};case n.Sibling:return function sibling(t){const n=a.getSiblings(t);for(let r=0;r<n.length;r++){const s=n[r];if(i(t,s))break;if(a.isTag(s)&&e(s))return true}return false};case n.Adjacent:return a.prevElementSibling?function adjacent(t){const n=a.prevElementSibling(t);return null!=n&&e(n)}:function adjacent(t){const n=a.getSiblings(t);let r;for(let e=0;e<n.length;e++){const s=n[e];if(i(t,s))break;a.isTag(s)&&(r=s)}return!!r&&e(r)};case n.Universal:if(null!=t.namespace&&"*"!==t.namespace)throw new Error("Namespaced universal selectors are not yet supported by css-select");return e}}
/**
 * Compiles a selector to an executable function.
 *
 * @param selector Selector to compile.
 * @param options Compilation options.
 * @param context Optional context for the selector.
 */function compile$1(e,t,n){const r=compileUnsafe(e,t,n);return ensureIsTag(r,t.adapter)}function compileUnsafe(e,t,n){const r="string"===typeof e?s(e):e;return compileToken(r,t,n)}function includesScopePseudo(e){return e.type===n.Pseudo&&("scope"===e.name||Array.isArray(e.data)&&e.data.some((e=>e.some(includesScopePseudo))))}const m={type:n.Descendant};const y={type:"_flexibleDescendant"};const b={type:n.Pseudo,name:"scope",data:null};function absolutize(e,{adapter:t},r){const s=!!(null===r||void 0===r?void 0:r.every((e=>{const n=t.isTag(e)&&t.getParent(e);return e===g||n&&t.isTag(n)})));for(const t of e){if(t.length>0&&isTraversal(t[0])&&t[0].type!==n.Descendant);else{if(!s||t.some(includesScopePseudo))continue;t.unshift(m)}t.unshift(b)}}function compileToken(e,r,s){var o;e.forEach(sortByProcedure);s=null!==(o=r.context)&&void 0!==o?o:s;const a=Array.isArray(s);const i=s&&(Array.isArray(s)?s:[s]);if(false!==r.relativeSelector)absolutize(e,r,i);else if(e.some((e=>e.length>0&&isTraversal(e[0]))))throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");let u=false;const l=e.map((e=>{if(e.length>=2){const[t,r]=e;t.type!==n.Pseudo||"scope"!==t.name||(a&&r.type===n.Descendant?e[1]=y:r.type!==n.Adjacent&&r.type!==n.Sibling||(u=true))}return compileRules(e,r,i)})).reduce(reduceRules,t.falseFunc);l.shouldTestNextSiblings=u;return l}function compileRules(e,n,r){var s;return e.reduce(((e,s)=>e===t.falseFunc?t.falseFunc:compileGeneralSelector(e,s,n,r,compileToken)),null!==(s=n.rootFunc)&&void 0!==s?s:t.trueFunc)}function reduceRules(e,n){return n===t.falseFunc||e===t.trueFunc?e:e===t.falseFunc||n===t.trueFunc?n:function combine(t){return e(t)||n(t)}}const defaultEquals=(e,t)=>e===t;const v={adapter:e,equals:defaultEquals};function convertOptionFormats(t){var n,r,s,o;const a=null!==t&&void 0!==t?t:v;null!==(n=a.adapter)&&void 0!==n?n:a.adapter=e;null!==(r=a.equals)&&void 0!==r?r:a.equals=null!==(o=null===(s=a.adapter)||void 0===s?void 0:s.equals)&&void 0!==o?o:defaultEquals;return a}function wrapCompile(e){return function addAdapter(t,n,r){const s=convertOptionFormats(n);return e(t,s,r)}}const w=wrapCompile(compile$1);const C=wrapCompile(compileUnsafe);const F=wrapCompile(compileToken);function getSelectorFunc(e){return function select(t,n,r){const s=convertOptionFormats(r);"function"!==typeof t&&(t=compileUnsafe(t,s,n));const o=prepareContext(n,s.adapter,t.shouldTestNextSiblings);return e(t,o,s)}}function prepareContext(e,t,n=false){n&&(e=appendNextSiblings(e,t));return Array.isArray(e)?t.removeSubsets(e):t.getChildren(e)}function appendNextSiblings(e,t){const n=Array.isArray(e)?e.slice(0):[e];const r=n.length;for(let e=0;e<r;e++){const r=getNextSiblings(n[e],t);n.push(...r)}return n}
/**
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elems Elements to query. If it is an element, its children will be queried..
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns All matching elements.
 *
 */const S=getSelectorFunc(((e,n,r)=>e!==t.falseFunc&&n&&0!==n.length?r.adapter.findAll(e,n):[]));
/**
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elems Elements to query. If it is an element, its children will be queried..
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns the first match, or null if there was no match.
 */const T=getSelectorFunc(((e,n,r)=>e!==t.falseFunc&&n&&0!==n.length?r.adapter.findOne(e,n):null));
/**
 * Tests whether or not an element is matched by query.
 *
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elem The element to test if it matches the query.
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns
 */function is(e,t,n){const r=convertOptionFormats(n);return("function"===typeof t?t:compile$1(t,r))(e)}export{F as _compileToken,C as _compileUnsafe,p as aliases,w as compile,S as default,d as filters,is,prepareContext,f as pseudos,S as selectAll,T as selectOne};

