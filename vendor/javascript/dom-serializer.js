import*as e from"domelementtype";import{encodeXML as t,escapeAttribute as n,escapeText as r}from"entities";const a=new Map(["altGlyph","altGlyphDef","altGlyphItem","animateColor","animateMotion","animateTransform","clipPath","feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feDropShadow","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence","foreignObject","glyphRef","linearGradient","radialGradient","textPath"].map((e=>[e.toLowerCase(),e])));const i=new Map(["definitionURL","attributeName","attributeType","baseFrequency","baseProfile","calcMode","clipPathUnits","diffuseConstant","edgeMode","filterUnits","glyphRef","gradientTransform","gradientUnits","kernelMatrix","kernelUnitLength","keyPoints","keySplines","keyTimes","lengthAdjust","limitingConeAngle","markerHeight","markerUnits","markerWidth","maskContentUnits","maskUnits","numOctaves","pathLength","patternContentUnits","patternTransform","patternUnits","pointsAtX","pointsAtY","pointsAtZ","preserveAlpha","preserveAspectRatio","primitiveUnits","refX","refY","repeatCount","repeatDur","requiredExtensions","requiredFeatures","specularConstant","specularExponent","spreadMethod","startOffset","stdDeviation","stitchTiles","surfaceScale","systemLanguage","tableValues","targetX","targetY","textLength","viewBox","viewTarget","xChannelSelector","yChannelSelector","zoomAndPan"].map((e=>[e.toLowerCase(),e])));const o=new Set(["style","script","xmp","iframe","noembed","noframes","plaintext","noscript"]);function replaceQuotes(e){return e.replace(/"/g,"&quot;")}function formatAttributes(e,r){var a;if(!e)return;const o=false===(null!==(a=r.encodeEntities)&&void 0!==a?a:r.decodeEntities)?replaceQuotes:r.xmlMode||"utf8"!==r.encodeEntities?t:n;return Object.keys(e).map((t=>{var n,a;const s=null!==(n=e[t])&&void 0!==n?n:"";"foreign"===r.xmlMode&&(t=null!==(a=i.get(t))&&void 0!==a?a:t);return r.emptyAttrs||r.xmlMode||""!==s?`${t}="${o(s)}"`:t})).join(" ")}const s=new Set(["area","base","basefont","br","col","command","embed","frame","hr","img","input","isindex","keygen","link","meta","param","source","track","wbr"]);
/**
 * Renders a DOM node or an array of DOM nodes to a string.
 *
 * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
 *
 * @param node Node to be rendered.
 * @param options Changes serialization behavior
 */function render(e,t={}){const n="length"in e?e:[e];let r="";for(let e=0;e<n.length;e++)r+=renderNode(n[e],t);return r}function renderNode(t,n){switch(t.type){case e.Root:return render(t.children,n);case e.Doctype:case e.Directive:return renderDirective(t);case e.Comment:return renderComment(t);case e.CDATA:return renderCdata(t);case e.Script:case e.Style:case e.Tag:return renderTag(t,n);case e.Text:return renderText(t,n)}}const l=new Set(["mi","mo","mn","ms","mtext","annotation-xml","foreignObject","desc","title"]);const d=new Set(["svg","math"]);function renderTag(e,t){var n;if("foreign"===t.xmlMode){e.name=null!==(n=a.get(e.name))&&void 0!==n?n:e.name;e.parent&&l.has(e.parent.name)&&(t={...t,xmlMode:false})}!t.xmlMode&&d.has(e.name)&&(t={...t,xmlMode:"foreign"});let r=`<${e.name}`;const i=formatAttributes(e.attribs,t);i&&(r+=` ${i}`);if(0===e.children.length&&(t.xmlMode?false!==t.selfClosingTags:t.selfClosingTags&&s.has(e.name))){t.xmlMode||(r+=" ");r+="/>"}else{r+=">";e.children.length>0&&(r+=render(e.children,t));!t.xmlMode&&s.has(e.name)||(r+=`</${e.name}>`)}return r}function renderDirective(e){return`<${e.data}>`}function renderText(e,n){var a;let i=e.data||"";false===(null!==(a=n.encodeEntities)&&void 0!==a?a:n.decodeEntities)||!n.xmlMode&&e.parent&&o.has(e.parent.name)||(i=n.xmlMode||"utf8"!==n.encodeEntities?t(i):r(i));return i}function renderCdata(e){return`<![CDATA[${e.children[0].data}]]>`}function renderComment(e){return`\x3c!--${e.data}--\x3e`}export{render as default,render};

